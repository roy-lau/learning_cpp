# 数据结构

**程序=算法+数据结构**

**数据结构=结构定义+结构操作**

## 时间复杂度

|复杂度 | 说明 | 例子🌰
|-|-|-
|`O(1)`| 常数 | 等差数列
|`O(logN)`| 对数 | 二分查找
|`O(n)`| 线性 | 一层 for 循环
|`O(nlogN)`| 线性对数 | 快速排序
|`O(n^2)`| 平方 | 两层 for 循环
|`O(n^3)`| 立方
|`O(n!)`| 阶乘
|`O(2n)`| 指数


## 时间复杂度

|复杂度 | 说明 | 例子🌰
|-|-|-
|`O(1)`| 常数 | 基本变量
|`O(n)`| 线性 | 一维数组
|`O(n^2)`| 平方 | 二维数组

## 线性表

### 前置知识

1. 指针：指向某元素的内存地址
2. 成员访问运算符的区别：“.” 与 “->”
3. 内存的分配与释放：内存管理系列函数
4. 参考手册：https://zh.cppreference.com/

### [顺序表](./3-1.vector.c)

线性表的顺序存储又叫做书序表，他是由一组地址连续的存储单元依次存储线性表的数据元素，从而使得逻辑上相邻的两个元素，在物理位置上也相邻（数组）。

顺序表既可以静态分配空间，又可以动态分配空间。动态分配空间时，需要将 data 变为指针。


### [单链表](./4-1.list.c)

顺序表的链式存储又叫做链表，在链表中每个元素的内存空间不连续，中间使用指针连接。

通常用链表头节点(head)指针域链表长度来表示一个单链表。

### 双链表

指针域处理指向后一个元素的指针外(next)，还有指向前一个元素的指针(front)，这样的链表是双链表。

通常用链表的头节点指针、为节点指针与链表长度来表示一个双链表。
双链表与单链表操作上相似，只需在单链表的基础上额外操作指向前一个节点的指针即可。

### 循环链表

在单链表的基础上，最后一个元素的指针指向第一个元素的链表，就是循环链表。

循环链表在存储时，一般存储尾节点与双链表相似，还有双向循环链表。

### 顺序表与链表的对比

1. 存取方式不同，是否支持随机访问。
2. 插入、删除、查找操作不同。
3. 空间分配不同。


## 栈与队列

### [栈](./5-1.stack.c)

栈(stack)是一种只允许在一端进行插入或删除的线性表，他是一种先进后出（FILO）的数据结构。在栈不为空时，我们只能看到栈顶元素。

术语：入栈（压栈）、出栈（弹栈）、栈顶、栈底、

- 栈的结构定义
```C
#define MaxCnt 50 // 栈当中元素的最大个数
struct Stack { // 栈的定义
  EleType data[MaxCnt]; // 栈的数据域
  int top; // 栈顶元素的位置
}
```

与顺序栈相对应的，还有一种“[链栈](./5-2.stack_list.c)”，顾名思义，是使用类似于链表的结构实现的  
还有一种“共享栈”（也成为对顶栈）：两个栈共享同一片内存空间。


### 队列

队列（Queue）是一种只允许在一端进行插入，在另一段进行删除的线性表，他是一种先进先出（FIFO）的数据结构。  
在队列不为空时，（一般的）我们只能看到队首元素。

术语：出队、入队、队首、队尾、队首元素、队尾元素、队列

- 队列的结构定义
```C
#define MaxCnt 50 // 队列当中元素的最大个数
struct Queue { // 队列定义
  EleType data[MaxCnt]; // 队列的数据域
  int front,back; // 队首元素与队尾元素的位置
}
```

由于普通的队列在入队出队的过程汇总指针的位置可能超过数据范围上限，所以一般在实现时使用循环队列。  
当指针指向上限时将这阵移动到最开始，与栈类似，也可以用链表的结果实现链式队列。


### 栈与队列复杂度对比

|栈 | 队列 |
|-|-|
|入栈 `O(1)` | 入队 `O(1)`
|出栈 `O(1)` | 出队 `O(1)`
|栈顶 `O(1)` | 队首 `O(1)`


## 树与二叉树

- 树节点的结构定义
```c
struct Node { // 树的结构定义
  EleType data; // 树节点的数据结构
  Node *child[]; // 子节点指针集合
}
```

对于子节点指针，有可能用数组是实现也有可能用链表是吸纳。  
树还可以用数组实现，只需记录每个节点的父节点即可。  

- 树的基本术语
  1. 父节点、子节点、兄弟节点、祖先、子孙
  2. 节点的度、树的度
  3. 叶子节点（终端节点）与分支节点（非终端节点）
  4. 节点的深度，高度和层次
  5. 路径与路径长度


## 森林与并查集

### 森林

> 树的集合是森林

#### 二叉树

> 有两个节点，左节点和右节点

- 二叉树中节点的结构定义
```C
struct Node { // 二叉树节点的定义
  EleType data; // 二叉树节点的数据域
  Node *left_child, *right_child; // 左子节点与右子节点指针
}
```

左子树与右子树也经常写作left(lchild)和 right(rchild) 同理二叉树也可以使用数组来存储

- 二叉树的基本术语
  1. 左孩子（左子树），右孩子（右子树）
  2. 每层的节点个数
  3. 满二叉树，完全二叉树
  4. 使用一维数组存储二叉树
  5. 广义表

- 二叉树的遍历
  - 深度搜索（递归）
    1. 先序遍历(树根->左子树->右子树)
    2. 中序遍历(左子树->树根->右子树)
    3. 后序遍历(左子树->右子树->树根)
  - 广度搜索（队列）  
    4. 层序遍历
  5. 根据遍历还原树

- 二叉树线索化
> 左前驱（ltag），右后继（rtag）

- 树与二叉树的转换
> 左孩子，右兄弟
树与二叉树的的先序遍历和中序遍历后的顺序是一致的。

- 二叉排序树（二叉查找树、二叉搜索树、BST 树）  
如果一课二叉树中的任意节点均满足，它左子树上所有的节点值都小于自身，它右子树上的所有节点都大于自身，那么这棵树即为二叉树。

- 哈夫曼树

给定 N 个权值作为 N 个叶子节点，构造一颗二叉树 带权路径长度（所有分支节点和根节点加在一起） 最小的二叉树称为哈夫曼树。  

构造方法为，每次选出两个权值最小的节点进行合并，将合并后的点放回后，重复上述过程，知道最终剩余一个节点作为根树。

- 哈夫曼编码

对于哈夫曼树中的叶子节点，从根节点出发向左子树移动编码为0，向右子树移动编码为 1 到达自身的所有路径连接起来即为该叶子节点的编码。


## 森林与并查集

### 森林

树的集合称为森林，树的根节点都是兄弟，其他子节点遵循左孩子右兄弟原则。

### [并查集](./8-1.union_set.c)

并查集就是多个集合，一个集合就是一棵树，树先用一维数组演示。

并查集有两个功能：合并、查询。